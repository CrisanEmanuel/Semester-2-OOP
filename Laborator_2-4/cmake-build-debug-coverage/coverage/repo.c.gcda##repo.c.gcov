        -:    0:Source:C:/Users/EMANUEL/Desktop/OOP/Laborator_2-4/repo.c
        -:    0:Graph:C:\Users\EMANUEL\Desktop\OOP\Laborator_2-4\cmake-build-debug-coverage\CMakeFiles\Laborator_2_4.dir\repo.c.gcno
        -:    0:Data:C:\Users\EMANUEL\Desktop\OOP\Laborator_2-4\cmake-build-debug-coverage\CMakeFiles\Laborator_2_4.dir\repo.c.gcda
        -:    0:Runs:1
        -:    1:#include "repo.h"
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
function createEmpty called 14 returned 100% blocks executed 100%
       14:    5:MyList createEmpty(){
        -:    6:    MyList rez;
       14:    7:    rez.capacitate = 1;
       14:    8:    rez.elems = malloc(sizeof(Offer) * rez.capacitate);
       14:    9:    rez.length = 0;
       14:   10:    return rez;
       14:   10-block  0
        -:   11:}
        -:   12:
function destroy called 11 returned 100% blocks executed 100%
       11:   13:void destroy(MyList *l){
       30:   14:    for (int i = 0; i < l -> length; i++){
       11:   14-block  0
       30:   14-block  1
branch  0 taken 19
branch  1 taken 11 (fallthrough)
       19:   15:        ElemType o = l -> elems[i];
       19:   16:        destroyOffer(&o);
       19:   16-block  0
call    0 returned 19
        -:   17:    }
        -:   18:    //nothing to deallocate for now
       11:   19:    l -> length = 0;
       11:   20:    free(l -> elems);
       11:   21:}
        -:   22:
function get called 36 returned 100% blocks executed 100%
       36:   23:ElemType get(MyList *l, int poz){
       36:   24:    return l -> elems[poz];
       36:   24-block  0
        -:   25:}
        -:   26:
function set called 5 returned 100% blocks executed 100%
        5:   27:ElemType set(MyList *l, int poz, ElemType el) {
        5:   28:    ElemType rez = l -> elems[poz];
        5:   29:    l -> elems[poz] = el;
        5:   30:    return rez;
        5:   30-block  0
        -:   31:}
        -:   32:
function size called 46 returned 100% blocks executed 100%
       46:   33:int size(MyList *l){
       46:   34:    return l -> length;
       46:   34-block  0
        -:   35:}
        -:   36:
function add called 29 returned 100% blocks executed 100%
       29:   37:void add(MyList *l, ElemType el){
       29:   38:    if (l -> capacitate <= l -> length){
       29:   38-block  0
branch  0 taken 16 (fallthrough)
branch  1 taken 13
        -:   39:        //sa alocam un spatiu mai mare
       16:   40:        ElemType* aux = malloc(sizeof(ElemType) * (l -> capacitate + 1));
        -:   41:        //copiem elementele
       39:   42:        for (int i = 0; i < l -> length; i++){
       16:   42-block  0
       39:   42-block  1
branch  0 taken 23
branch  1 taken 16 (fallthrough)
       23:   43:            aux[i] = l -> elems[i];
       23:   43-block  0
        -:   44:        }
       16:   45:        free(l -> elems);
       16:   46:        l -> elems = aux;
       16:   47:        l -> capacitate += 1;
       16:   47-block  0
        -:   48:    }
       29:   49:    l -> elems[l -> length] = el;
       29:   50:    l -> length++;
       29:   51:}
        -:   52:
        -:   53:
function copyList called 5 returned 100% blocks executed 100%
        5:   54:MyList copyList(MyList* l) {
        5:   55:    MyList rez = createEmpty();
        5:   55-block  0
call    0 returned 5
       19:   56:    for (int i = 0; i < size(l); i++) {
       19:   56-block  0
call    0 returned 19
branch  1 taken 14
branch  2 taken 5 (fallthrough)
       14:   57:        ElemType o = get(l, i);
       14:   57-block  0
call    0 returned 14
       14:   58:        add(&rez, createOffer(o.type, o.area, o.address, o.price));
call    0 returned 14
call    1 returned 14
        -:   59:    }
        5:   60:    return rez;
        5:   60-block  0
        -:   61:}
        -:   62:
function sterge_oferta_repo called 2 returned 100% blocks executed 100%
        2:   63:int sterge_oferta_repo(MyList *l, char *tip, char *adresa){
        2:   64:    int i = 0;
        4:   65:    while(i < l -> length){
        2:   65-block  0
        4:   65-block  1
branch  0 taken 3
branch  1 taken 1 (fallthrough)
        3:   66:        Offer o = get(l, i);
        3:   66-block  0
call    0 returned 3
        3:   67:        if (strcmp(tip, o.type) == 0 && strcmp(adresa, o.address) == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   67-block  0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1:   68:                destroyOffer(&o);
        1:   68-block  0
call    0 returned 1
        3:   69:                for (int j = i; j < l -> length - 1; j++)
        3:   69-block  0
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2:   70:                    l -> elems[j] = l -> elems[j + 1];
        2:   70-block  0
        1:   71:                l -> length -= 1;
        1:   72:                return 0;
        1:   72-block  0
        -:   73:        }
        2:   74:        i++;
        2:   74-block  0
        -:   75:    }
        1:   76:    return -1;
        1:   76-block  0
        -:   77:}
        -:   78:
function actualizeaza_oferta_repo called 2 returned 100% blocks executed 100%
        2:   79:int actualizeaza_oferta_repo(MyList *l, char *type, char *address, ElemType el){
        3:   80:    for (int i = 0; i < l -> length; i++) {
        2:   80-block  0
        1:   80-block  1
        3:   80-block  2
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2:   81:        Offer o = get(l, i);
        2:   81-block  0
call    0 returned 2
        2:   82:        if (strcmp(type, o.type) == 0 && strcmp(address, o.address) == 0){
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:   82-block  0
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1:   83:            set(l,i,el);
        1:   83-block  0
call    0 returned 1
        1:   84:            return 0;
        -:   85:        }
        -:   86:    }
        1:   87:    return -1;
        1:   87-block  0
        -:   88:}
